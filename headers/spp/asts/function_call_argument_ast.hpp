#pragma once
#include <spp/asts/ast.hpp>
#include <spp/asts/mixins/orderable_ast.hpp>
#include <spp/asts/mixins/type_inferrable.hpp>


/**
 * The FunctionCallArgumentAst is the base class representing an argument in a function call. It is inherited into the
 * "positional" and "keyword" variants.
 */
struct spp::asts::FunctionCallArgumentAst : virtual Ast, mixins::OrderableAst, mixins::TypeInferrableAst {
    using Ast::Ast;
    friend PostfixExpressionOperatorFunctionCallAst;

protected:
    /**
     * When an argument is generated by the compiler for the "self" type being injected into a method call, the type is
     * passed explicitly to speed up inference.
     */
    std::shared_ptr<TypeAst> m_self_type;

public:
    /**
     * The convention on the argument being passed into the function call. Conventions are applicable to both positional
     * and keyword arguments.
     */
    std::unique_ptr<ConventionAst> conv;

    /**
     * The expression that is being passed as the argument to the function call. Both positional and keyword arguments
     * have a value.
     */
    std::unique_ptr<ExpressionAst> val;

    /**
     * Construct the FunctionCallArgumentAst with the arguments matching the members.
     * @param conv The convention on the argument being passed into the function call.
     * @param val The expression that is being passed as the argument to the function call.
     */
    FunctionCallArgumentAst(
        decltype(conv) &&conv,
        decltype(val) &&val,
        decltype(m_order_tag) order_tag);

    ~FunctionCallArgumentAst() override;

    auto stage_7_analyse_semantics(ScopeManager *sm, mixins::CompilerMetaData *meta) -> void override;

    auto stage_8_check_memory(ScopeManager *sm, mixins::CompilerMetaData *meta) -> void override;

    auto infer_type(ScopeManager *sm, mixins::CompilerMetaData *meta) -> std::shared_ptr<TypeAst> override;

    auto set_self_type(std::shared_ptr<TypeAst> self_type) -> void;

    auto get_self_type() -> std::shared_ptr<TypeAst>;
};
